타임리프 : 
서버사이드렌더링 하는거 (백엔드에서 html 동적으로 렌더링)
네츄럴 템플릿 : 순수HTML을 최대한 유지해서 웹에서 열어봐도 파일안깨짐
th:utext= unescape처리, 태그적용할때 등 "<"를 "<"그대로 읽음

th:inline="none" : 타임리프로 해석하지 말란뜻 

escape처리를 기본으로 하고, 특수상황에서만 unescape를 쓴다

변수선언 th:with="변수명=${데이터}"

컨텐츠 안에서 직접 출력하기 = [[${data}]]

타임리프가 제공한다 기본객체
${#locale}

편의 객체도 제공한다.
HTTP 요청 파라미터 접근: param
예) ${param.paramData}
HTTP 세션 접근: session
예) ${session.sessionData}
스프링 빈 접근: @
예) ${@helloBean.hello('Spring!')}


유틸리티 객체와 날짜
타임리프는 문자, 숫자, 날짜, URI등을 편리하게 다루는 다양한 유틸리티 객체들을 제공한다.
필요할떄 메뉴얼 보고 쓰면댐
타임리프 유틸리티 객체들
#message : 메시지, 국제화 처리
#uris : URI 이스케이프 지원
#dates : java.util.Date 서식 지원
#calendars : java.util.Calendar 서식 지원
#temporals : 자바8 날짜 서식 지원
#numbers : 숫자 서식 지원
#strings : 문자 관련 편의 기능
#objects : 객체 관련 기능 제공
#bools : boolean 관련 기능 제공
#arrays : 배열 관련 기능 제공
#lists , #sets , #maps : 컬렉션 관련 기능 제공
#ids : 아이디 처리 관련 기능 제공, 뒤에서 설명

URL링크
url표현 : th:href="@{/hello}"
url에 파라미터 넣는 법 : th:href="@{/hello(param1=${param1}, param2=${param2})}"
url에 경로 넣는 법 : th:href="@{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}"
url에 경로와 파람 넣는 법 : th:href="@{/hello/{param1}(param1=${param1}, param2=${param2})}"
(경로 매핑후 남는애들은 파라미터로 들어감)

리터럴
타임리프에서 문자리터럴은 항상 ' (작은따옴표)로 감싸야한다
공백없이 쭉이어진다면 생략해도된다
리터럴 대체문법 :  th:text="|hello ${data}|"
"'hello ' + ${data}" 대신 대체문법으로 편하게 쓸 수 있따

연산
비교연산: HTML 엔티티를 사용해야 하는 부분을 주의하자, 
> (&gt;) (gt), < (&lt;) (lt), >= (ge), <= (le), ! (not), == (eq), != (neq, ne)
조건식: 자바의 조건식과 유사하다.  th:text="(조건식)? 'true식':'false식'"
Elvis 연산자: 조건식의 편의 버전. true면 data출력.  th:text="${data}?: 'false식'"
No-Operation: _ 인 경우 마치 타임리프가 실행되지 않는 것 처럼 동작한다.   
<span th:text="${data}?: _">데이터가 없습니다.</span> : true면 data 출력, false면 span태그 내부 텍스트 실행됨.
이것을 잘 사용하면 HTML의 내용 그대로 활용할 수 있다. 마지막 예를 보면 데이터가 없습니다. 부분이 그대로 출력된다

속성값 설정
th:*로 HTML태그의 기존속성 대체하거나 없으면 새로만든다
기존 속성의 속상값 앞뒤에 속성값 추가/붙이기 가능 : th:attrappend="", th:attrprepend=""
예시) th:attrappend="class=' large'"
th:classappend : 클래스는 별도로 th:classappend="large" 와 같이 사용 가능
html은 checked속성 존재시 무조건 체크표시 되지만, 타임리프에선 th:checked="false"하면 체크해제됨

반복
th:each="변수 : ${리스트등등}" : for문과동일동작, 변수.값으로 값 꺼내 쓴다
예시)
<tr th:each="user : ${users}">
    <td th:text="${user.username}">username</td>
    <td th:text="${user.age}">0</td>
</tr>
반복 상태 유지
<tr th:each="user, userStat : ${users}"> 혹은 <tr th:each="user : ${users}">한담에 변수명Stat으로 호출해서 사용
반복의 두번째 파라미터를 설정해서 반복의 상태를 확인 할 수 있습니다.
두번째 파라미터는 생략 가능한데, 생략하면 지정한 변수명( user ) + Stat 가 됩니다.
여기서는 user + Stat = userStat 이므로 생략 가능합니다.
반복 상태 유지 기능
index : 0부터 시작하는 값
count : 1부터 시작하는 값
size : 전체 사이즈
even , odd : 홀수, 짝수 여부( boolean )
first , last :처음, 마지막 여부( boolean )
current : 현재 객체

조건식-if문
th:if나 unless값이 false면 해당 태그 아예 표시 안된다
if문 : th:if="${user.age lt 20}"
if문반대(조건불만족시트루) : th:unless="${user.age ge 20}"
조건식-switch문
th:switch="${조건식}"후 th:case="값", th:case="*"는 디폴트 실행
<td th:switch="${user.age}">
    <span th:case="10">10살</span>
    <span th:case="20">20살</span>
    <span th:case="*">기타</span>
</td>

주석
1. 표준 HTML 주석  <!--구문 -->
자바스크립트의 표준 HTML 주석은 타임리프가 렌더링 하지 않고, 그대로 남겨둔다.
2. 타임리프 파서 주석  <!--/*-->여러줄<!--*/-->
타임리프 파서 주석은 타임리프의 진짜 주석이다. 렌더링에서 주석 부분을 제거한다.
3. 타임리프 프로토타입 주석	<!--/*/ 구문 /*/-->
HTML 파일을 그대로 열어보면 주석처리가 되지만, 타임리프를 렌더링 한 경우에만 보이는 기능이다.

블록 : th는 보통 속성으로 사용되지만, each만으로 안되는 경우 자체 태그 사용해서 해결
<th:block> 은 HTML 태그가 아닌 타임리프의 유일한 자체 태그다
예시) for문 돌리면서 두 영역을 나눠 표현하고싶을때

자바스크립트 인라인 : 자바스크립트에서 타임리프 편리하게 사용하게해줌
<script th:inline="javascript">
텍스트 렌더링 : 스트링타입에 " 하지않아도 변수에 알아서 스트링으로 삽입해줌
내추럴 템플릿 :  HTML 파일을 직접 열어도 동작하는 내추럴 템플릿 기능을 제공한다.
var username2 = /*[[${user.username}]]*/ "test username";
인라인 사용 전 var username2 = /*userA*/ "test username";
인라인 사용 후 var username2 = "userA";
객체 : 객체는 알아서 객체타입Json으로 넣어줌.
